### 250727

### 문제 풀이
# ✅ [코드트리 문제풀이] 양수 직사각형의 최대 넓이

> https://www.codetree.ai/ko/trails/complete/curated-cards/test-max-area-of-positive-rectangle/description  
> 난이도: ⭐⭐⭐☆☆  
> 사용 언어: Java  
> 분류: 완전탐색 / 2차원 배열

---

### 🧩 문제 설명

2차원 배열이 주어졌을 때,  
**내부의 모든 값이 양수인 직사각형 중 가장 넓은 넓이**를 출력하는 문제이다.

조건:
- 배열 크기: `n x m`
- 원소는 음수 또는 양수
- 결과가 존재하지 않으면 `-1`을 출력

---

### 💡 해결 아이디어

1. **시작점 선택**  
   모든 칸을 시작점(`startx`, `starty`) 후보로 탐색하되, 값이 양수인 칸만 선택한다.

2. **직사각형 크기 완전탐색**  
   - 시작점을 기준으로 가능한 모든 가로 길이(`j`)와 세로 길이(`i`)를 완전탐색한다.
   - 내부 모든 값이 **양수인지 확인**한 뒤 넓이를 계산한다.

3. **최댓값 갱신**  
   조건을 만족하는 경우 넓이(`size = i * j`)를 계산하여 `max` 값과 비교해 갱신한다.

---

### 🔎 코드 (Java)

'''java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] grid = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                grid[i][j] = sc.nextInt();
        // Please write your code here.

        /*
        문제 조건 정리)
        1.내부의 모든 원소의 값이 양수를 확인.
        2.그 중 가장 큰 직사각형을 생성.

        해결 방법)
        1. 찾는 직사각형의 왼쪽 상단 원소를 첫 원소(=start)로 잡고
           우선 양수인 start를 찾는다.
        2. start를 기준으로 가능한 가로 길이(=w)와 세로 길이(=h)까지 for문으로 완전탐색하여
           음수가 나오면 넘어가고 양수가 나와 for 문이 종료될 때, 크기 값 size를 등록한다.
        3. size 중 가장 큰 값을 max에 갱신한다.
        */

        int startx = 0, starty = 0; // 시작점 start의 x, y 좌표
        int w = 1, h = 1;
        int size = -1, max = -1; // 만일 충족하는 직사각형이 없다면 -1을 출력해야함.

        for(starty = 0; starty < n; starty++){
            for(startx = 0; startx < m; startx++){
                if(grid[starty][startx] < 0) continue;
                else{
                    
                    for(int i = 1; i <= (n - starty); i++){
                        for(int j = 1; j <= (m - startx); j++){
                            
                            boolean positive = true;
                            for(int dy = starty; (positive == true) && dy < (starty + i); dy++){
                                for(int dx = startx; (positive == true) && dx < (startx +j); dx++){
                                    if(grid[dy][dx] <= 0) { positive = false; }
                                }
                            }

                            if(positive == true){
                                size = i*j;
                                //System.out.println("시작 : " + startx + " " + starty + " 크기 " + i + "*"+ j + " = " + size);
                                if(size > max) { max = size; }
                            }
                        }
                    }
                }
            }
        }

        System.out.println(max);
    }
}

### 🧠 핵심 포인트
모든 시작점을 기준으로 완전탐색

양수인 구간만 조건 만족

2중 for문으로 사각형 크기 확장 → 내부 값 체크

### ⏱️ 시간 복잡도
최악의 경우
O(n * m * n * m)
→ 각 시작점마다 가능한 모든 직사각형을 검사함

비효율적이지만 문제에서 허용하는 범위 내에서는 통과

### ✅ 출력 예시
입력:
3 3
1 1 -1
1 1 1
-1 1 1

출력:
4
(→ (1,1) ~ (2,2) 영역 2x2 직사각형)

### ✏️ 느낀점
- 완전탐색의 기본기를 점검할 수 있는 문제였다.
- 2차원 배열을 기준으로 영역을 지정하고 조건을 확인하는 연습에 좋았다.
- 시간 복잡도는 크지만, 조건을 만족하므로 통과할 수 있다.