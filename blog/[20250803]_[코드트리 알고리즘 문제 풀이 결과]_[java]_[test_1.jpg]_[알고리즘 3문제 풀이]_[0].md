### 250803

### 오늘의 목표

- 코드트리의 알고리즘 문제 3개 풀이 작성하기


###

# 회전하는 삼각형 벨트

## 문제 링크  
[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-conveyor-belt-triangle/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-conveyor-belt-triangle/description)

## 문제 요약  
길이가 n인 3개의 벨트가 삼각형 형태로 연결되어 있다. 각 벨트는 회전이 가능하며, 이 삼각형 벨트 구조에서 한 번 회전하면 다음과 같이 값이 이동한다:  
- 왼쪽 벨트의 맨 끝 값이 아래 벨트의 맨 앞에 삽입  
- 아래 벨트의 맨 끝 값이 오른쪽 벨트의 맨 앞에 삽입  
- 오른쪽 벨트의 맨 끝 값이 왼쪽 벨트의 맨 앞에 삽입  
이를 t번 반복한 후 각 벨트 상태를 출력한다.

---

## 풀이 아이디어

- 각 벨트는 배열로 표현하고, 배열을 오른쪽으로 한 칸씩 밀어주는 방식으로 구현한다.
- 임시 변수 3개를 사용하여 끝값들을 순차적으로 교환하면서 회전을 구현한다.
- `while(t > 0)` 루프 안에서 회전 작업을 수행하고, t를 1씩 줄여 종료 조건으로 사용한다.

---

## 내가 작성한 코드 (Java)

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int t = sc.nextInt();
        int[] l = new int[n];
        int[] r = new int[n];
        int[] d = new int[n];
        for (int i = 0; i < n; i++) {
            l[i] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            r[i] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            d[i] = sc.nextInt();
        }

        int temp1, temp2, temp3;

        while(t > 0){
            temp1 = l[n-1];
            temp2 = r[n-1];
            temp3 = d[n-1];

            for(int i = n-1; i > 0; i--)
                l[i] = l[i-1];
            l[0] = temp3;

            for(int i = n-1; i > 0; i--)
                r[i] = r[i-1];
            r[0] = temp1;

            for(int i = n-1; i > 0; i--)
                d[i] = d[i-1];
            d[0] = temp2;

            t--;
        }

        for(int i = 0; i < n; i++)
            System.out.print(l[i] + " ");
        System.out.println();
        for(int i = 0; i < n; i++)
            System.out.print(r[i] + " ");
        System.out.println();
        for(int i = 0; i < n; i++)
            System.out.print(d[i] + " ");
    }
}
```

---

## 복잡도 분석

- 시간 복잡도: O(t × n)  
  (각 회전마다 3개의 배열을 각각 n번 이동 → 총 3×n = O(n) 반복 × t회)
- 공간 복잡도: O(n)  
  (세 개의 길이 n 배열과 약간의 임시 변수 사용)

---

## 정답 코드 (비교용)

```java
// 불필요한 변수 생성을 줄이고 배열 회전 순서를 더 명확하게 구분
// 의미 있는 변수명과 세분화된 단계 주석으로 가독성 향상

while(t-- > 0) {
    int temp = l[n - 1];

    for(int i = n - 1; i >= 1; i--)
        l[i] = l[i - 1];
    l[0] = d[n - 1];

    int temp2 = r[n - 1];
    for(int i = n - 1; i >= 1; i--)
        r[i] = r[i - 1];
    r[0] = temp;

    for(int i = n - 1; i >= 1; i--)
        d[i] = d[i - 1];
    d[0] = temp2;
}
```

---

## 회고 / 개선점

- 내 코드는 세 개의 temp 변수를 명확하게 선언하고 교환 규칙을 충실히 따랐으나,  
  실제로는 필요한 temp는 두 개만 있어도 충분하다.
- 정답 코드에서는 `temp`, `temp2`만으로 흐름을 자연스럽게 이어가며 변수 사용을 최소화하였다.
- 또한 for 루프를 거꾸로 (i >= 1)로 돌려 배열 이동과 복사 구조를 더 명확히 보여준다.
- 반복 횟수 감소를 위해 `while(t-- > 0)` 구조도 익숙해질 필요가 있다.
- **배운 점**: 문제에서 요구하는 구조 변화가 단순 반복일 경우, 배열 회전을 위한 최소한의 값 추적만으로 문제를 해결할 수 있다. 간결한 구현과 불필요한 복사 방지를 염두에 두자.


###

# 1차원 바람이 분다

## 문제 링크  
[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-The-1D-wind-blows/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-The-1D-wind-blows/description)

## 문제 요약  
n행 m열로 구성된 2차원 격자에서 특정 행에 바람이 좌우(L/R)로 분다.  
- 바람을 받은 행은 한 칸씩 왼쪽 또는 오른쪽으로 밀린다.  
- 이후, 인접한 위/아래 행에서 같은 열에 같은 숫자가 있으면 해당 행도 밀리며,  
  바람의 방향은 반대로 전파된다.  
- 이러한 밀림 현상은 같은 숫자가 더 이상 존재하지 않을 때까지 위/아래로 확산된다.

---

## 풀이 아이디어

1. 바람의 방향에 따라 주어진 행을 한 칸 밀기 (왼쪽 or 오른쪽)
2. **전파 조건**: 인접 행과 현재 행이 같은 열에서 동일한 값을 가지면, 영향을 받아 한 칸 밀림
3. 전파 방향: 위쪽 → 아래쪽 순으로 검사하며, 방향은 계속 반전됨
4. `while`문 대신 변수 추적을 통한 `for`문으로 전파 범위 제어

---

## 내가 작성한 코드 (Java)

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int q = sc.nextInt();
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                a[i][j] = sc.nextInt();
        for (int i = 0; i < q; i++) {
            int r = sc.nextInt();
            char d = sc.next().charAt(0);

            boolean blowup = false, blowdown = false;

            // 바람 맞은 행 밀기
            if(d == 'R'){
                int temp = a[r-1][0];
                for(int k = 0; k < m-1; k++){
                    a[r-1][k] = a[r-1][k+1];
                }
                a[r-1][m-1] = temp;
            }else if(d == 'L'){
                int temp = a[r-1][m-1];
                for(int k = m-1; k > 0; k--){
                    a[r-1][k] = a[r-1][k-1];
                }
                a[r-1][0] = temp;
            }

            // 인접 행 검사
            for(int k = 0; n > 1 && k < m; k++){
                if(r == 1 && a[r-1][k] == a[r][k]) blowup = true;
                else if(r == n && a[r-1][k] == a[r-2][k]) blowdown = true;
                else if(r > 1 && r < n){
                    if(a[r-1][k] == a[r][k]) blowup = true;
                    if(a[r-1][k] == a[r-2][k]) blowdown = true;
                }
            }
            
            // 위 방향 전파
            int colup = r; char dup = d;
            while(blowup && colup < n){
                if(dup == 'L'){
                    int temp = a[colup][0];
                    for(int k = 0; k < m-1; k++) a[colup][k] = a[colup][k+1];
                    a[colup][m-1] = temp;
                    dup = 'R';
                } else {
                    int temp = a[colup][m-1];
                    for(int k = m-1; k > 0; k--) a[colup][k] = a[colup][k-1];
                    a[colup][0] = temp;
                    dup = 'L';
                }

                if(colup == n-1) break;
                blowup = false;
                for(int k = 0; k < m; k++){
                    if(a[colup][k] == a[colup+1][k]){
                        blowup = true;
                        colup++;
                        break;
                    }
                }
            }

            // 아래 방향 전파
            int coldown = r-2; char ddown = d;
            while(blowdown && coldown >= 0){
                if(ddown == 'L'){
                    int temp = a[coldown][0];
                    for(int k = 0; k < m-1; k++) a[coldown][k] = a[coldown][k+1];
                    a[coldown][m-1] = temp;
                    ddown = 'R';
                } else {
                    int temp = a[coldown][m-1];
                    for(int k = m-1; k > 0; k--) a[coldown][k] = a[coldown][k-1];
                    a[coldown][0] = temp;
                    ddown = 'L';
                }

                if(coldown == 0) break;
                blowdown = false;
                for(int k = 0; k < m; k++){
                    if(a[coldown][k] == a[coldown - 1][k]){
                        blowdown = true;
                        coldown--;
                        break;
                    }
                }
            }
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                System.out.print(a[i][j] + " ");
            }
            System.out.println();
        }        
    }
}
```

---

## 복잡도 분석

- 시간 복잡도: O(q × n × m)  
  - 각 연산마다 최대 n개의 행을 검사 및 이동하고, 각 이동은 m 길이
- 공간 복잡도: O(n × m)  
  - 입력 격자 전체 저장

---

## 정답 코드 (비교용)

```java
// 함수 분리 (shift, hasSameNumber, simulate)로 가독성과 재사용성 향상
// 전파 방향 통일: 위/아래 모두 for문으로 간결하게 구성
// 방향은 상수로 처리하여 의미 명확화 (SHIFT_LEFT, SHIFT_RIGHT)

public static void shift(int row, int dir) {
    // dir이 0: 오른쪽, dir이 1: 왼쪽
    if(dir == SHIFT_RIGHT) {
        int temp = a[row][m];
        for(int col = m; col >= 2; col--)
            a[row][col] = a[row][col - 1];
        a[row][1] = temp;
    } else {
        int temp = a[row][1];
        for(int col = 1; col <= m - 1; col++)
            a[row][col] = a[row][col + 1];
        a[row][m] = temp;
    }
}
```

---

## 회고 / 개선점

- 내 코드는 문제 풀이 흐름을 충실히 따랐고, 바람의 전파 방향을 while 루프로 구현하여 실제 전파 과정을 직접 확인할 수 있다.
- 하지만 정답 코드는 함수화(shift, hasSameNumber, flip)를 통해 가독성을 높이고, 디버깅과 유지보수에 유리하다.
- **특히 반대 방향 전파 로직**을 for 루프로 통일해 코드 흐름이 훨씬 깔끔하며, row index 조작이 더 안정적이다.
- 좌우 밀기 방향도 `SHIFT_LEFT`, `SHIFT_RIGHT`라는 상수를 활용해 코드를 명확하게 만든 점이 인상적이다.
- **배운 점**: 조건문이 많은 로직에서는 유틸 함수로 분리하여 가독성과 확장성을 높이는 것이 중요하다.


###


# 2차원 바람이 분다

## 문제 링크  
[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-The-2D-wind-blows/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-The-2D-wind-blows/description)

## 문제 요약  
n × m 격자에 대해 q개의 쿼리가 주어진다. 각 쿼리는 직사각형 영역을 지정하며, 다음 두 작업을 수행한다:  
1. 직사각형의 테두리 값을 **시계 방향**으로 한 칸씩 회전  
2. 직사각형 내부의 각 칸을 중심으로 상하좌우(총 5칸) 값의 **평균**으로 갱신  
이 과정을 q번 반복한 뒤 결과 격자를 출력한다.

---

## 풀이 아이디어

- 쿼리마다 회전 + 평균 작업을 분리해서 처리한다.
- 회전: 직사각형 테두리 네 면을 순서대로 한 칸씩 이동 (4번의 루프 필요)
- 평균 처리: 전체를 동시에 갱신해야 하므로, 임시 배열을 사용하여 값을 저장 후 한 번에 복사
- 평균은 상하좌우 + 자기자신 총 5칸을 기준으로 계산한다.

---

## 내가 작성한 코드 (Java)

```java
import java.util.Scanner;

public class Main {

    public static int around_avg(int[][] a, int n, int m, int dy, int dx){
        if (dy < 0 || dy >= n || dx < 0 || dx >= m) return 0;
        
        int sum = a[dy][dx]; int count = 1;
        if((dy-1) >= 0) { sum += a[dy-1][dx]; count++; }
        if((dx-1) >= 0) { sum += a[dy][dx-1]; count++; }
        if((dy+1) < n) { sum += a[dy+1][dx]; count++; }
        if((dx+1) < m) { sum += a[dy][dx+1]; count++; }
        return (sum/count);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int q = sc.nextInt();
        int[][] building = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                building[i][j] = sc.nextInt();
        int[][] queries = new int[q][4];

        for (int i = 0; i < q; i++){
            for (int j = 0; j < 4; j++){
                queries[i][j] = sc.nextInt();
            }

            int r1 = queries[i][0] - 1, c1 = queries[i][1] - 1, r2 = queries[i][2] - 1, c2 = queries[i][3] - 1;
            int w = (c2-c1+1), h=(r2-r1+1);
            int[][] newarr = new int[h][w];

            int temp1 = building[r1][c1], temp2 = building[r1][c2], temp3 = building[r2][c2], temp4 = building[r2][c1];
            for(int l = c2; l > c1; l--)
                building[r1][l] = building[r1][l-1]; 
            for(int k = r2; k > r1; k--)
                building[k][c2] = building[k-1][c2];
            for(int l = c1; l < c2; l++)
                 building[r2][l] = building[r2][l+1];
            for(int k = r1; k < r2; k++)
                building[k][c1] = building[k+1][c1];
            building[r1][c1+1] = temp1; building[r1+1][c2] = temp2; building[r2][c2-1] = temp3; building[r2-1][c1] = temp4;

            for(int k = 0; k < h; k++){
                for(int l = 0; l < w; l++){
                    int dy = r1 + k;
                    int dx = c1 + l;
                    newarr[k][l] = around_avg(building, n, m, dy, dx);
                }
            }

            for(int k = 0; k < h; k++){
                for(int l = 0; l < w; l++){
                    int dy = r1 + k;
                    int dx = c1 + l;
                    building[dy][dx] = newarr[k][l];
                }
            }
        }
        
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++){
                System.out.print( building[i][j] + " " );
            }
            System.out.println();
        }
    }
}
```

---

## 복잡도 분석

- 시간 복잡도: O(q × (n + m))  
  - 회전은 테두리 네 변을 따라 O(n + m), 평균은 내부 전체 순회
- 공간 복잡도: O(n × m)  
  - 임시 배열 `newarr` 사용

---

## 정답 코드 (비교용)

```java
// rotate(): 회전 전용 함수로 모서리 처리와 네 방향 밀기 로직 분리
// average(): dx/dy 배열을 사용해 상하좌우+자기 자신 평균 계산
// setAverage(): 평균은 temp 배열에 먼저 저장 후 한꺼번에 복사

public static void rotate(int startRow, int startCol, int endRow, int endCol) {
    int temp = a[startRow][startCol];
    for(int row = startRow; row < endRow; row++)
        a[row][startCol] = a[row + 1][startCol];
    for(int col = startCol; col < endCol; col++)
        a[endRow][col] = a[endRow][col + 1];
    for(int row = endRow; row > startRow; row--)
        a[row][endCol] = a[row - 1][endCol];
    for(int col = endCol; col > startCol; col--)
        a[startRow][col] = a[startRow][col - 1];
    a[startRow][startCol + 1] = temp;
}
```

---

## 회고 / 개선점

- 내 코드는 하나의 `main` 함수 내에 모든 기능이 내포되어 있고, 직사각형 회전과 평균 계산이 함께 처리되어 직관적이지만 **유지보수에 어려움**이 있다.
- 정답 코드에서는 회전, 평균 계산, 시뮬레이션을 명확하게 함수로 분리하여 **모듈화와 가독성**을 높였다.
- 특히 dx/dy 배열을 활용한 평균 계산 로직은 반복을 줄이고 코드의 안정성을 높이는 좋은 습관이다.
- **배운 점**: 계산 순서를 시각화하고, 동시에 갱신되는 연산은 임시 배열을 통해 처리하는 습관을 들이자.