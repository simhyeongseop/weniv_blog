### 250817

### 오늘의 목표

- 육각형개발자 책에서 소개하는 이해하기 쉬운 코드 작성법 정리하기



###

# 읽기 쉬운 코드 작성법 — 『육각형 개발자』를 읽고 정리 (Java 예시 포함)

> 최범균 지음 · 한빛미디어  
> 이 글은 사용자가 『육각형 개발자』를 읽고 정리한 초안을 바탕으로, **이해하기 쉬운 코드**를 만드는 원칙을 다듬고 Java 예시를 추가한 글입니다.

---

## 왜 “읽기 쉬움(Readable)”이 중요한가
- **협업/인수인계 속도**가 빨라집니다. 남이 읽을 수 있어야 팀이 확장됩니다.
- **버그 탐지/수정**이 쉬워집니다. 의도가 보이면 테스트도 정확해집니다.
- **변경 비용**이 줄어듭니다. 작은 단위로 나뉜 코드는 안전하게 바뀝니다.

---

## 1) 이름: 의도를 드러내고, 도메인 용어를 쓰자
- 축약/암호화보다 **도메인 언어** 사용: `dc` 대신 `daysSinceCreation`, `map` 대신 `emailByCustomer`.
- 단위/형태가 중요하면 이름에 드러내기: `expiresAtUtc`, `amountKrw`, `iso8601`.
- `doIt`, `process`, `handle` 같은 포괄어는 피하고 구체적 동사 사용.

```java
// ❌ 나쁨
int d; Map<String, String> m; boolean f;

// ✅ 좋음
int daysSinceCreation;
Map<CustomerId, EmailAddress> emailByCustomer;
boolean isActive; // 긍정형 불리언
```

메서드도 마찬가지입니다.

```java
// ❌ 나쁨
void process(Order o) { /* ... */ }

// ✅ 좋음
void placeOrder(Order order) { /* ... */ }
```

---

## 2) 중첩 if 최소화: Guard Clause & Early Return
- **비정상/경계 조건을 먼저 거절**해 행복 경로를 평평하게 만듭니다.
- 깊은 중첩을 피하고 빠르게 반환/예외를 던집니다.

```java
// ❌ 중첩된 if
void ship(Order order) {
    if (order != null) {
        if (order.isPaid()) {
            if (!order.isShipped()) {
                // ...
            }
        }
    }
}

// ✅ 가드 절
void ship(Order order) {
    if (order == null) throw new IllegalArgumentException("order is null");
    if (!order.isPaid()) throw new IllegalStateException("order not paid");
    if (order.isShipped()) return; // 이미 처리됨
    // 행복 경로
    // ...
}
```

---

## 3) 변수 줄이기: 스코프를 좁히고, 재사용(다목적) 금지
- **사용 직전에 정의**하고, 가능한 **짧은 블록**에 가둡니다.
- 한 변수를 **여러 의미로 재사용하지 않기**.

```java
// ❌ temp 변수를 여기저기 재사용
int temp = 0;
for (Item i : items) temp += i.price();
double avg = (double) temp / items.size();
temp = 0; // 재사용 시작
for (Item i : items) if (i.isDiscounted()) temp++;

// ✅ 역할별 이름과 좁은 스코프
int totalPrice = items.stream().mapToInt(Item::price).sum();
double averagePrice = (double) totalPrice / items.size();

long discountedCount = items.stream().filter(Item::isDiscounted).count();
```

---

## 4) 값 변경(가변성) 최소화: `final`과 불변(Immutable) 선호
- 중간에 값이 계속 변하면 추적이 어렵습니다. **불변 데이터**는 사고 범위를 줄입니다.
- 컬렉션은 **방어적 복사**/불변 래퍼 사용.

```java
// 값 객체(Value Object) 예시
public final class Money {
    private final long amountKrw;

    public Money(long amountKrw) { this.amountKrw = amountKrw; }
    public long amountKrw() { return amountKrw; }

    public Money add(Money other) { return new Money(this.amountKrw + other.amountKrw); }
}

// 컬렉션 불변화
public final class Order {
    private final List<Item> items;
    public Order(List<Item> items) {
        this.items = List.copyOf(items); // 방어적 복사 + 불변 리스트
    }
    public List<Item> items() { return items; }
}
```

---

## 5) 알맞은 파라미터 타입: 필요한 것만, 정확한 타입으로
- `Map<String, Object>` 같은 만능 타입은 **분석 비용**을 키웁니다.
- **필요한 값만** 받도록 **전용 타입**/Value Object/Parameter Object를 도입합니다.

```java
// ❌ 나쁨: 만능 파라미터
void schedule(Map<String, Object> params) {
    // "start" 가 Date인지 String인지? "tz"는 어떤 형식?
}

// ✅ 좋음: 전용 타입
record ScheduleRequest(LocalDateTime start, Duration duration, ZoneId zoneId) { }

void schedule(ScheduleRequest req) {
    // req.start(), req.duration(), req.zoneId()
}
```

필드가 늘면 **Builder**를 고려해 가독성을 유지합니다.

```java
var req = new NotificationRequest.Builder()
        .to(userId)
        .title("Welcome")
        .body("Hello")
        .urgent(false)
        .build();
```

---

## 6) 길지 않은 코드 & 메서드 추출: 한 가지 일만 하게
- 긴 메서드는 **의도 단위로 추출**합니다.
- 상위 메서드는 **한 수준의 추상화**만 유지합니다.

```java
// ✅ 상위 수준의 흐름만 남기기
public Receipt checkout(Cart cart, PaymentMethod method) {
    validate(cart);
    Money total = calculateTotal(cart);
    charge(method, total);
    return printReceipt(cart, total);
}

private void validate(Cart cart) { /* ... */ }
private Money calculateTotal(Cart cart) { /* ... */ }
private void charge(PaymentMethod method, Money amount) { /* ... */ }
private Receipt printReceipt(Cart cart, Money total) { /* ... */ }
```

---

## 7) 추상화 수준 맞추기: 계층/경계를 섞지 말기
- DB/네트워크 호출(낮은 수준)과 도메인 정책(높은 수준)을 한 메서드에 섞지 않습니다.
- **Hexagonal(Ports & Adapters)** 스타일로 **경계**를 분리합니다.

```java
// 포트(Port): 도메인이 바라보는 인터페이스
public interface PaymentGateway {
    PaymentResult pay(Money amount, PaymentMethod method);
}

// 도메인 서비스: 정책/흐름
public class PaymentService {
    private final PaymentGateway gateway;
    public PaymentService(PaymentGateway gateway) { this.gateway = gateway; }

    public Receipt checkout(Cart cart, PaymentMethod method) {
        validate(cart);
        Money total = calculateTotal(cart);
        PaymentResult r = gateway.pay(total, method); // 외부 호출은 포트로
        return createReceipt(cart, total, r);
    }
}

// 어댑터(Adapter): 실제 외부 시스템 연동
public class NicepayAdapter implements PaymentGateway {
    public PaymentResult pay(Money amount, PaymentMethod method) {
        // HTTP 호출/변환/에러 매핑 등
    }
}
```

동일 메서드 안에서 “SQL 작성 + 비즈니스 규칙 판정 + HTTP 호출”이 섞여 있다면 **추상화 수준이 뒤섞인 신호**입니다. 분리하세요.

---

## (보완) 이해하기 쉬움을 높이는 추가 팁

### A. Null 다루기: `Optional`/Null Object
```java
// ✅ Optional 반환
Optional<User> findByEmail(EmailAddress email);

// 사용 측
User user = findByEmail(email).orElseThrow(() -> new NotFound("user"));
```

### B. 명령-조회 분리(CQS)
- **조회**는 상태를 바꾸지 않고 값을 반환, **명령**은 상태를 바꾸고 값을 반환하지 않거나 식별자만 반환.

```java
// 조회
Order findOrder(OrderId id);

// 명령
void approveOrder(OrderId id, Approver approver);
```

### C. 예외 메시지에 문맥 담기
```java
throw new IllegalStateException("order %s is already shipped".formatted(order.id()));
```

### D. 시간/외부 의존성 래핑
```java
// 테스트 가능한 시간 의존성
interface Clock { Instant now(); }
class SystemClock implements Clock { public Instant now() { return Instant.now(); } }
```

---

## 체크리스트 (요약)
- [ ] 이름에 의도/단위/도메인을 담았다.  
- [ ] 중첩 if 대신 가드 절/조기 반환을 썼다.  
- [ ] 변수 스코프를 좁히고, 재사용하지 않았다.  
- [ ] 가능한 `final`/불변 구조를 선호했다.  
- [ ] 매개변수는 필요한 값만, 정확한 타입으로 받았다.  
- [ ] 메서드는 짧고, 한 수준의 추상화만 유지했다.  
- [ ] 외부 I/O와 도메인 규칙을 분리했다(Port/Adapter).  
- [ ] null 대신 Optional/Null Object를 고려했다.  
- [ ] 예외/로그에 문맥을 남겼다.  
- [ ] 테스트가 사용법과 의도를 설명한다.  

---

## 느낀 점 (요약)
자료구조에서 배운 추상화 개념(ADT)이 실무의 “읽기 쉬운 코드” 원칙과 그대로 연결된다는 점이 인상적이었습니다. 작은 과제에서도 겪은 가독성 문제는 팀 프로젝트·현업으로 갈수록 **비용이 기하급수적으로 커진다**는 사실을 체감했습니다. 앞으로는 **의도 중심의 이름짓기**, **가드 절**, **불변 선호**, **경계 분리**를 기본기로 삼아 팀의 오해를 줄이고 변경 친화적인 코드를 지향하겠습니다.
